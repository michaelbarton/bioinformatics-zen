---
  kind: article
  feed: true
  title: Automating the selection of genome assembly software
  date: "2018-03-23 07:00 GMT"
  authors: "Alicia Clum, Alex Copeland, and Kecia Duffy"
---

 <p>The selection of the optimal assembler an important part of processing genomic data, where each assembly represents a hypothesis as to the best way to reconstruct a genome from the sequencing reads. An open question is what is the best way to determine if the produced assembly is good, and by what criteria? Previous approaches including the Assemblathon 1 <span class="citation">[<a href="#ref-earl2011">1</a>]</span>, Assemblathon 2 <span class="citation">[<a href="#ref-bradnam2013">2</a>]</span>, GAGE <span class="citation">[<a href="#ref-salzberg2012">3</a>]</span>, and CAMI <span class="citation">[<a href="#ref-sczyrba2017">4</a>]</span> have surveyed the different available assembly methods.</p>
 <p>The “nucleotid.es” project is an automated benchmarking framework to examine short read assembly software. The aim of automating benchmarking was to have an always up-to-date overview of the current state of efficacy, performance, and correctness for genome assembly software. The testing data included 16 different microbial genomes, where each source organism had five technical replicates generated by sampling without replacement from a superset of reads. Each assembler was then benchmarked against a total of 80 FASTQ files. All the microbial sources used are listed in <a href="#tab:table-organisms">Table 9</a>. None of the sequencing data used were preprocessed by any tools prior to assembly, and can be considered as ‘raw’ Illumina sequencing data. Though not recommended practice, this simplified the analysis by allowing comparison of assembly pipelines containing preprocessing steps.</p>
 <p>Examining a data set containing a variety of different microbial genomes allows estimating confidence intervals, and ideally the identification of small differences in assembler efficacy. As the JGI sequences thousands of microbial genomes, even a small improvement in assembly quality could result in thousands of additional correct genome features. To this end ‘nucleotid.es’ collected 5.6 million metrics across 18.57 million assembled contigs, using a combined total of approximately 8.8k CPU hours.</p>
 <p>This automated benchmarking approach was made possible through the use of Docker images with standardised interfaces to the majority of recent genome assembly software, via the <a href="http://bioboxes.org">bioboxes project</a> <span class="citation">[<a href="#ref-belmann2015">5</a>]</span> developed in conjunction with <a href="https://twitter.com/_pbelmann_">Peter Belmann</a> and our other CAMI collaborators. The use of bioboxes increases the utility of the performance metrics to be useful to the microbial genomics community, since researchers can download and use exactly the same Docker image in their own work as was benchmarked here.</p>
 <p>The metrics were generated using <a href="http://quast.sourceforge.net/quast">QUAST</a> 4.5 and an internally-develop JGI tool: <a href="https://gitlab.com/michaelbarton/gaet">GAET</a>. QUAST is described in Gurevich <em>et. al</em> 2013 <span class="citation">[<a href="#ref-gurevich2013">6</a>]</span>, while GAET compares a reference genome and an assembly by looking at the differences in the two respective annotation sets. The assemblers compared in this analysis were ABySS <span class="citation">[<a href="#ref-simpson2009">7</a>]</span>, A5-miseq <span class="citation">[<a href="#ref-coil2015">8</a>]</span>, GATB Minia <span class="citation">[<a href="#ref-chiki2013">9</a>]</span>, LightAssembler <span class="citation">[<a href="#ref-metwally2016">10</a>]</span>, MEGAHIT <span class="citation">[<a href="#ref-li2015">11</a>]</span>, Ray <span class="citation">[<a href="#ref-boisvert2010">13</a>]</span>, Shovill, SPAdes <span class="citation">[<a href="#ref-bankevich2012">14</a>]</span>, StriDe <span class="citation">[<a href="#ref-huang2016">15</a>]</span>, BBTools Tadpole, Unicycler <span class="citation">[<a href="#ref-wick2017">16</a>]</span>, and Velvet <span class="citation">[<a href="#ref-zerbino2008">17</a>]</span>. The isolate assembly pipeline being used in production at the JGI was also included in the analysis. This pipeline is several preprocessing steps using BBTools followed by assembly with SPAdes. All the versions of each short read assembler Docker image used in this analysis are listed in <a href="#tab:table-images">Table 8</a>.</p>
 <p>Many different approaches have been used to examine and define genome quality <span class="citation">[<a href="#ref-ghodsi2013">18</a>]</span>, <span class="citation">[<a href="#ref-simao2015">19</a>]</span>, <span class="citation">[<a href="#ref-meader2010">20</a>]</span>, <span class="citation">[<a href="#ref-parks2015">21</a>]</span>, <span class="citation">[<a href="#ref-phillippy2008">22</a>]</span>, <span class="citation">[<a href="#ref-hunt2013">23</a>]</span>, <span class="citation">[<a href="#ref-florea2011">24</a>]</span>, <span class="citation">[<a href="#ref-vezzi2012">25</a>]</span>. There is no consensus within the bioinformatics community on what a single unified assembly quality metric. This analysis instead compares assemblers using the several quality metrics that have been commonly used previously. Furthermore all the ‘nucleotid.es’ data generated here are <a href="https://s3-us-west-1.amazonaws.com/notebook-data/2017-11-aggregated-assembly-metrics/nucleotides_isolate_benchmarking.csv.gz">available for download</a> so that anyone may also do their own assessment, according to which assembly metrics are most useful to their own work. This data set contains 100s of metrics per assembly based on comparing a set of contigs as the “observed” assembly against a reference sequence as the “expected” genome using both QUAST and GAET . The analysis presented here is also an <a href="http://rmarkdown.rstudio.com/">RMarkdown</a> document containing all the R code used. You can <a href="https://gitlab.com/michaelbarton/rmd-aggregated-assembly-metrics">view the source or submit a pull request through the gitlab repository</a>.</p>
 <div id="modelling-genome-assembler-efficacy" class="section level2 unnumbered">
    <h2>Modelling genome assembler efficacy</h2>
    <p>The aim of generating the ‘nucleotid.es’ data was to estimate the efficacy of each assembler. As each assembler was benchmarked across multiple different genomes, any estimate for assembler efficacy needed to account for some genomes being more difficult to assemble than others. Any estimate should be an aggregate across all assessed genomes while holding any genome-specific differences constant.</p>
    <p>To this end, linear models were used to estimate two different coefficients, one for each assembler, and one for each genome. As an example the NA50 value of any given genome assembly was split into two components: the first component measured the overall difficulty of assembling the genome, such as might be limited by genomic repeats. The second component measured the assembler efficacy, where given the same input data, each assembler produces more or less contiguous assemblies.</p>
    <p><a href="#eq:model-fit">Equation 1</a> shows an example where NA50 is the sum of the estimated coefficients for two components plus any error unaccounted for in the model, using SPAdes and <em>E. coli</em>. In this equation, the model estimated value for <span class="math inline">\(\beta_1\)</span> represents the efficacy of an assembler holding the differences in genome <span class="math inline">\(\beta_2\)</span> constant. This value, along with the associated confidence intervals, was used as a measure for assembler efficacy. The natural logarithm of the genome length (<span class="math inline">\(ln. length\)</span>) was included to account for differences in genome length. Using a log-link function for the linear model means that changes  in the estimated explanatory coefficients have a log. normal change in the response variable.</p>

    <span class="math display" id="eq:model-fit">\[\begin{align}
    \begin{split}
    \frac{metric}{length} &amp; = exp. \left(\beta_1 \cdot assembler + \beta_2 \cdot genome \right) + \epsilon \\
    \\
    metric &amp; = exp. \left(\beta_1 \cdot assembler + \beta_2 \cdot genome + 1 \cdot ln.\ length \right) + \epsilon \\
    \\
    NA50 &amp; = exp. \left(-3.196 \cdot SPAdes + -0.30781 \cdot E.coli + 1 \cdot 15.35 \right) + - 6890 \\
    &amp; = 139,552\ bp \\
    \end{split}
    \tag{1}
    \end{align}\]</span>

    <p>We wanted to use model fitting to measure genome assembler efficacy, accounting for noise and differences in genomes, however it was not clear <em>a priori</em> which model to use. Selecting a model ourselves could introduce biases based on our own intuitions about what the most accurate model should be. The ideal scenario was to allow the data to inform us as to which model to use. Therefore, the first step in this analysis was to test different mixed-effect linear models<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> to determine which best describes genome assembler efficacy. The aim was to compare different hypotheses, including the null, and select the most parsimonious given the data.</p>
    <p>The Bayesian information criterion (BIC) was used to rank to each model, where BIC is the log-likelihood of the model penalised by the number of free parameters, multiplied by number of data points. The model with the lowest BIC was the one selected as the most parsimonious - that which best fits the data without overfitting by using too many parameters.<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> The models tested to explain the variance in assembles are listed in <a href="#tab:model-table">Table 6</a>.</p>
    <p>Random slopes were not considered as all the dependent variables were categorical. Each model had a random effect intercept fitted. Each random intercept was fitted for the terms described below.</p>
    <ul>
       <li>
          <p><strong>Null</strong> - No random intercept terms were fitted.</p>
       </li>
       <li>
          <p><strong>Genome</strong> - A different random intercept coefficient was fitted for each source genome term.</p>
       </li>
       <li>
          <p><strong>FASTQ file</strong> - A different random intercept coefficient was fitted for each FASTQ file term.</p>
       </li>
    </ul>
    <p>These random intercepts allowed for each model to account for genome or input file differences in the data that were not specific to the assembler. Each model also had four variations in fixed-effect explanatory variable. These were:</p>
    <ul>
       <li>
          <p><strong>Null</strong> - assembly quality is random regardless of which assembler is used.</p>
       </li>
       <li>
          <p><strong>Assembler</strong> - the explanatory effect for assembly quality is the assembler used, regardless of the version or command line arguments.</p>
       </li>
       <li>
          <p><strong>Assembler Version</strong> - the explanatory effect for assembly quality is the version of the assembler used, regardless of command line arguments.</p>
       </li>
       <li>
          <p><strong>Assembler Args</strong> - the explanatory effect for assembly quality is the command line arguments for that version of the assembler used.</p>
       </li>
    </ul>
    <p>The “Fixed Effect” and “Random Effect” components allowed for fitting different coefficients (<span class="math inline">\(\beta_1, \beta_2\)</span>) averaged across the data. This was suitable for measuring single point-estimates, however we also wanted to estimate 95% confidence intervals for each assembler. Confidence intervals allowed comparing each assembler conservatively using the expected worst-case result. I.e. instead of comparing by the mean performance of each assembler, compare by the lower 5% confidence interval.</p>
    <p>In addition to estimating mean coefficients for each genome or assembler, different variances were considered too. This modelled whether the efficacy of one assembler had a wider range of results than another. These variance components are listed in the ‘Variance Model’ column of <a href="#tab:model-table">Table 6</a>. Each row lists which term was used to estimate a coefficient for the variance. Null indicates a single global term was estimated for the entire model, i.e. a mixed-effect model with no specific modelling of variance.</p>
 </div>
 <div id="example-model-fitting-for-contiguity" class="section level2 unnumbered">
    <h2>Example model fitting for contiguity</h2>
    <p>As an example, model fitting and comparison was performed by fitting each these model using NA50 as the explanatory variable. <a href="#fig:plot-na50-dist">Figure 1</a> shows the distribution of NA50 values scaled by the length of the source genome. NA50, a metric used to assess assembly quality based on contiguity, is defined as the contig length where the cumulative sum of the ordered contigs lengths in the assembly was at least half the total assembly length, removing any contigs that don’t align to the reference sequence. Scaling NA50 by the reference length controls for the size of the genome when comparing assemblies from two different source organisms. This becomes a unitless metric between 0-1, where 1 represents an assembly without any gaps.</p>
    <p><a href="#fig:plot-na50-dist">Figure 1</a> shows that scaled NA50 is distributed across four orders of magnitude from <span class="math inline">\(10^{-3} - 10^{0}\)</span>, and is variable both between organisms and within the same organism. The figure highlights that assembly quality appears to be highly dependent on the organism being sequenced, even when accounting for the differences in the length of the source organism using the <emph>ln. length</emph> term in <a href="#eq:model-fit">Equation 1</a>. This effect is modelled by the <span class="math inline">\(\beta_2\)</span> component in <a href="#eq:model-fit">Equation 1</a>, the per-organism variability in assembly quality. In the case of contiguity, this is likely due to the repeat content of the genome and short read length <span class="citation">[<a href="#ref-koren2015">28</a>]</span>. The effect of GC content or number of repeats in the genome were not considered, all these factors would instead be lumped into the single genome-specific term.</p>

  <%= partial(:figure, :locals => {
    anchor: "fig:plot-na50-dist",
    url: amzn('aggregated-assembly-metrics/01-nag50-by-assembler.png'),
    caption_name: "Figure 1: Plot of NA50 distribution across genome assembler version.",
    caption_desc: "The x-axis is NA50 scaled by source genome length, shown on a log. scale. The rows on the y-axis are the benchmark genomes ordered by the geometric mean across all assemblies. Each facet plot shows all the different assembly values across all assemblers in grey, with the specific values for that assembler highlighted. Organism labels are hidden for brevity."}) %>

    <figure id="tab:na50-model-summary">
    <table>
       <thead>
          <tr class="header">
             <th align="left">Fixed Term</th>
             <th align="left">Random Term</th>
             <th align="left">Variance Model</th>
             <th align="right">dBIC</th>
             <th align="right">R.D.F.</th>
             <th align="right">Dev.</th>
             <th align="left">Conv.</th>
          </tr>
       </thead>
       <tbody>
          <tr class="odd">
             <td align="left">Assembler Args</td>
             <td align="left">Genome</td>
             <td align="left">Assembler Args + Genome</td>
             <td align="right">0.00</td>
             <td align="right">3627.001</td>
             <td align="right">82812.7</td>
             <td align="left">T</td>
          </tr>
          <tr class="even">
             <td align="left">Assembler Args</td>
             <td align="left">Input FASTA</td>
             <td align="left">Assembler Args + Input FASTA</td>
             <td align="right">967.93</td>
             <td align="right">3499.019</td>
             <td align="right">82727.2</td>
             <td align="left">T</td>
          </tr>
          <tr class="odd">
             <td align="left">Assembler Version</td>
             <td align="left">Genome</td>
             <td align="left">Assembler Version + Genome</td>
             <td align="right">1674.87</td>
             <td align="right">3677.001</td>
             <td align="right">84899.1</td>
             <td align="left">T</td>
          </tr>
          <tr class="even">
             <td align="left">Assembler</td>
             <td align="left">Genome</td>
             <td align="left">Assembler + Genome</td>
             <td align="right">2134.88</td>
             <td align="right">3697.001</td>
             <td align="right">85523.8</td>
             <td align="left">T</td>
          </tr>
          <tr class="odd">
             <td align="left">Assembler Args</td>
             <td align="left">Genome</td>
             <td align="left">Assembler Args</td>
             <td align="right">2160.55</td>
             <td align="right">3642.001</td>
             <td align="right">85096.7</td>
             <td align="left">T</td>
          </tr>
          <tr class="even">
             <td align="left">Assembler Version</td>
             <td align="left">Input FASTA</td>
             <td align="left">Assembler Version + Input FASTA</td>
             <td align="right">2656.14</td>
             <td align="right">3549.027</td>
             <td align="right">84827.0</td>
             <td align="left">T</td>
          </tr>
       </tbody>
    </table>
    <%= partial(:figure_caption, :locals => {
      caption_name: "Table 1: Summary of first six most parsimonious models with NA50 as the response variable.",
      caption_desc: "The dBIC shows the difference in Bayesian information criterion between the best model and all other models. ‘R.D.F.’ is the residual degrees of freedom in the model. ‘Dev.’ is the residual deviance in the model. ‘Conv.’ states whether the model converged or not (T/F)." })%>
    </figure>

    <p>All the models described (<a href="#tab:model-table">Table 6</a>) were fitted with NA50 as the response variable. The best five models according to lowest BIC are listed in <a href="#tab:na50-model-summary">Table 1</a>. This table shows the dBIC, residual deviance, and residual degrees of freedom for each model.<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a> The dBIC value shows the delta between each model and the model with the lowest BIC. Therefore the most parsimonious model for explaining variance in NA50, according to BIC, was assembler command line arguments with a random effect for source genome and variance components for both assembler arguments and genome. The next most parsimonious model had a dBIC much higher than 10, indicating there is no support for it or any other models <span class="citation">[<a href="#ref-burnham2002">29</a>]</span>.</p>
    <p>As an aside, the null model with only the random effect for source organism was more parsimonious compared with the subset of models using only software as an explanatory effect without a random effect for source genome(not shown in the table for clarity). This emphasises the importance considering the biological source when benchmarking bioinformatics software, and any performance metrics must account for inherent random effects in the benchmark data used. The model comparison suggests not accounting for this is likely to conflate the efficacy of the software with the inherent differences in the data used for benchmarking.</p>
 </div>
 <div id="examining-assembly-metrics" class="section level2 unnumbered">
    <h2>Examining assembly metrics</h2>
    <p>Contiguity metrics such as NA50, count only the contigs that align to the reference. In addition to NA50, misassemblies, indels, mismatches, and Ns are regularly used to examine the quality of an assembly. These other metrics are useful to describe an assembly because incorrect regions in assemblies are likely to be annotated incorrectly, which can then subsequently change downstream analysis of the genomic features in these erroneous regions.</p>
    <p>The above modelling approach used to examine NA50 was also applied to the number of misassemblies, and the number of incorrect bases in the same assemblies determined by aligning to the reference. The number of incorrect bases was defined as the sum of indels, mismatches and Ns. The estimated assembler coefficients (<span class="math inline">\(\beta_1\)</span> in <a href="#eq:model-fit">Equation 1</a>) from the most parsimonious model in each case are shown in <a href="#fig:plot-assembler-parameters">Figure 2</a>. These assembler coefficients are point estimates with 95% confidence intervals from a log-normal distribution.<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a> The assemblers are ranked by the worst bound on the confidence intervals, which is the lower bound in the case of NA50 and the upper bound for number of misassemblies, and incorrect bases. In the cases where multiple different command line arguments for the same version were tested, the assemblers were ranked by the command line arguments that gave the “least-worst” coefficient by confidence interval. The least-worst was determined by ranking all the command line parameter sets within the same tool version, and selecting the set with the highest lower bound on the estimated coefficient confidence intervals. Ranking by least-worst on the lower bound of the confidence interval estimates was because assemblers with large confidence intervals could generate both very good and very poor results. Using the lower bound ranks assemblers by the worst-case expected result.</p>

  <%= partial(:figure, :locals => {
    anchor: "fig:plot-assembler-parameters",
    url: amzn('aggregated-assembly-metrics/02-assembly-aggregated-metrics.png'),
    caption_name: "Figure 2: Plot of assembly quality metrics by genome and assembler.",
    caption_desc: "Each figure shows the efficacy of the assembler coefficients estimated from a linear model accounting for both the genome and the assembler software used. The error bars show the 95\% confidence intervals for each estimate. The x-axis for the model coefficient plots are ordered by the least-worst bound on the confidence interval for each assembler. Figures A and C include the different versions of the assembly software used. Figure B does not include the assembly software version because the most parsimonious model indicated software version is not a factor in rate for the assemblers and versions tested."}) %>

    <p><a href="#fig:plot-assembler-parameters">Figure 2</a>A shows the linear-model estimated NA50 coefficient for each assembler, the model coefficients are exponentiated to appear on 0-1 scale as NA50 scaled by reference genome length. The estimated coefficients show that the choice of genome assembler had a relatively minor effect on the contiguity of the assembly, where most assemblers can be expected to produce similar contiguity. The exceptions to this are LightAssembler and MEGAHIT/1.0.6. MEGAHIT versions 1.0.6 and 1.1.1 have different estimates with non-overlapping confidence intervals, highlighting the important of considering and reporting which version of an assembler was used in any genomic analysis. Overall though the choice of assembler appears to have only a minor affect on contiguity.</p>
    <p><a href="#fig:plot-assembler-parameters">Figure 2</a>B shows the estimated average misassembly coefficients for each genome assembler, exponentiated to return to the original scale. The estimated coefficients are more uniformly distributed across a range of values than the estimated NA50 coefficients. In this case there are assemblers such as LightAssembler, tadpole and MEGAHIT that generate fewer misassemblies than assemblers such as Ray, Minia, StriDe and the JGI isolate pipeline. The assemblers that have the largest coefficients for NA50, also tend to have the largest coefficients for misassemblies per megabase, indicating an positive relationship between contiguity and misassemblies.</p>
    <p>Comparing the estimated coefficients for incorrect bases per megabase in <a href="#fig:plot-assembler-parameters">Figure 2</a>C shows that LightAssembler and Minia tend to generate larger numbers of incorrect bases, while all the other assemblers tend to produce much lower values.</p>
    <p>In two metric plots, two of the assemblers velvet and LightAssembler had a small estimated coefficients with a large confidence interval range. This may indicate model difficulty in estimating accurate coefficients, which could be due to both of these assemblers failing to produce results for some benchmarks (<a href="#tab:table-missing-data">Table 7</a>). To put this another way, the worst results for both assemblers produced no assemblies at all, which could skew the data. Future analysis could develop an unbiased method of handling missing data.</p>
    <p>For contiguity the most parsimonious model indicates that assembler arguments are relevant (<a href="#tab:na50-model-summary">Table 1</a>), for misassemblies the most parsimonious model indicates that only the assembler is relevant regardless of version or assembler arguments (<a href="#tab:table-misassembly-models">Table 3</a>), and for incorrect bases the most parsimonious model indicates only the assembler version is relevant (<a href="#tab:table-incorrect-models">Table 4</a>).</p>
 </div>
 <div id="effect-of-assembler-choice-on-annotations" class="section level2 unnumbered">
    <h2>Effect of assembler choice on annotations</h2>
    <p>The NA50, misassemblies and incorrect bases metrics all measure different components of assembly quality. Assemblies with better values for these metrics should be more representative of the true genome sequence. As mentioned earlier, an outstanding issue is the lack of a single metric to determine which genome assembly software to use. As an example of this are the results in <a href="#fig:plot-assembler-parameters">Figure 2</a>A and <a href="#fig:plot-assembler-parameters">2</a>B indicate that optimising for contiguity is likely to increase misassembly rate, and vice versa. The ideal case is a single metric which may be used as an objective function not only for selecting assembly software, but also for making other optimisations, such as to library and sequencing protocols. The ideal function would be a weighted combination of different metrics drawn from the requirements of the users of the pipeline, and representing different orthogonal axes of assembly quality.</p>
    <p>All of the metrics examined so far are likely to affect the annotations in the assembly. A break in contiguity, a misassembly, or an incorrect base in a genome feature could result in no feature being annotated, or possibly worse a misannotation. Therefore using annotated genomic features may be a useful proxy for a single metric, combining multiple different metrics at once. This is an issue specifically raised by Florea <em>et. al</em> <span class="citation">[<a href="#ref-florea2011">24</a>]</span> where differences in cow genome assemblies result in thousands of predicted gene differences.</p>
    <p>Annotation changes between assemblies can be estimated by comparing the difference between the genome feature sequences in the assembly and the reference sets<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a>. This distance can be measured as the L1 norm of annotations. The L1 norm is the sum over the following function: for each distinct annotation in the superset of the assembly and the reference, 0 if the annotation appears in both the reference and the assembly, and 1 otherwise. The recently open sourced JGI tool <a href="https://gitlab.com/michaelbarton/gaet">GAET</a> was developed to estimate this.</p>

  <%= partial(:figure, :locals => {
    anchor: "fig:plot-feature-dist",
    url: amzn('aggregated-assembly-metrics/03-l1-norm-by-assembler.png'),
    caption_name: "Figure 3: Plot of genome feature correctness by assembler version.",
    caption_desc: "The x-axis is the L1 norm distance of the annotated features between the assembly and the reference, shown on a log. scale. The rows on the y-axis are the benchmarked genomes ordered by the geometric mean across all assemblies. Each facet plot shows all the different assembly values across all assemblers in grey, with the specific values for that assembler highlighted. The y-axis is ordered by the geometric mean of values for each organism. Organism labels are hidden for brevity."}) %>

  <%= partial(:figure, :locals => {
    anchor: "fig:plot-feature-coef",
    url: amzn('aggregated-assembly-metrics/04-l1-norm-aggregated-metrics.png'),
    caption_name: "Figure 4: Plot of assembler average genome feature L1 norm distance coefficients.",
    caption_desc: "Coefficients were estimated from a linear model accounting for both the genome and the assembler software used. The error bars show the 95\% confidence intervals for each estimate. The x-axis is ordered by the lower bound on the confidence interval. The estimated coefficient for LightAssembler is not included on this scale due to it being much greater than all other estimated coefficients."}) %>

    <p><a href="#fig:plot-feature-dist">Figure 3</a> compares annotation L1 norm distance per megabase for all the genomes used in benchmarking, across all assemblers. The higher the L1 norm, the larger the difference between the reference and assembly annotated feature sets. In the majority of cases, the number of annotations different between the reference and the assembly is fewer than 200 per megabase, not including any genome specific effects. The exceptions to this were MEGAHIT/1.0.6 and LightAssembler which in many cases had a much larger number of differences compared with the other assemblers.</p>
    <p>Similarly to the previous sections, the same models listed in <a href="#tab:model-table">Table 6</a> were fitted to describe the L1 norm distance between each assembly and the corresponding reference. The model for assembler with a random effect for source genome is the most parsimonious (<a href="#tab:table-feature-models">Table 5</a>). The again emphasises the importance of including the source genome when estimating software efficacy. <a href="#fig:plot-feature-coef">Figure 4</a> shows the model estimated coefficients for the least-worst set of arguments for each assembler version. The figure shows that MEGAHIT/1.0.6 had higher number of incorrect annotations than the majority of the other assemblers, while this appears to be much improved in MEGAHIT/1.1.1. This again emphasises the importance of considering versioning in bioinformatics software. Light assembler could not be shown on the same scale as the other assemblers due to the estimated coefficient being much greater than the other assemblers. Outside of MEGAHIT/1.0.6 and LightAssembler the difference between the best and worst performing assembler was approximately 25 incorrect annotations per megabase. Therefore the choice of genome assembler is expected to have a non-trivial effect on downstream annotated features.</p>

    <figure id="tab:assemblers-by-feature-table">
    <table>
       <thead>
          <tr class="header">
             <th align="left">Assembler</th>
             <th align="left">Version</th>
             <th align="left">Biobox Task</th>
             <th align="right">Estimate</th>
          </tr>
       </thead>
       <tbody>
          <tr class="odd">
             <td align="left">jgi-isolate-pipeline</td>
             <td align="left">v0.11.0</td>
             <td align="left">default</td>
             <td align="right">52.99</td>
          </tr>
          <tr class="even">
             <td align="left">stride</td>
             <td align="left">0.0.1</td>
             <td align="left">default</td>
             <td align="right">53.44</td>
          </tr>
          <tr class="odd">
             <td align="left">jgi-isolate-pipeline</td>
             <td align="left">v0.12.0</td>
             <td align="left">merge</td>
             <td align="right">53.55</td>
          </tr>
          <tr class="even">
             <td align="left">shovill</td>
             <td align="left">0.7.1</td>
             <td align="left">default</td>
             <td align="right">53.60</td>
          </tr>
          <tr class="odd">
             <td align="left">spades</td>
             <td align="left">3.11.0-fix-merge-task</td>
             <td align="left">merge</td>
             <td align="right">53.59</td>
          </tr>
          <tr class="even">
             <td align="left">jgi-isolate-pipeline</td>
             <td align="left">v0.12.0</td>
             <td align="left">experimental</td>
             <td align="right">54.02</td>
          </tr>
       </tbody>
    </table>

    <%= partial(:figure_caption, :locals => {
      caption_name: "Table 2: List of five best performing assemblers by average L1 norm feature distance between the reference genome and the generated assembly.",
      caption_desc: "The ‘Assembler’, ‘Version’ and ‘Biobox Task’ columns refer to the parameters used to run the Docker image containing the software. The ‘Biobox Task’ refers to the biobox task name that can be used to replicate the command line arguments used for benchmarking. The ‘Estimate’ column is the upper 95% confidence interval on the average L1 norm distance across all the benchmark genomes. Larger values indicate an expected greater number of incorrect features in an assembly." }) %>

    </figure>

    <p><a href="#tab:assemblers-by-feature-table">Table 2</a> lists the top five assembler biobox Docker images according the upper 95% confidence interval on the linear model estimated efficacy of each assembler. This table illustrates how linear models may be used to generate a single metric for each assembler across a range of benchmark genomes, which can then be used to automatically rank and select the assembly pipeline providing the likely greatest number of correct annotations. This analysis suggests at this time version v0.11.0 of the JGI isolate pipeline biobox, running the ‘default’ task was the best choice of assembler for microbial isolate Illumina sequencing data. This improves over running SPAdes alone by approximately 0.5 correct features per megabase, highlighting how preprocessing raw sequence data before assembly can result in improvements over using the raw data alone. The high ranking of shovill and StriDe assemblers, both of which also contain trimming and error correction, also points to how preprocessing can increase the expected number of correct annotations.</p>
    <p>These conclusions are based on the data used, and different data may produce different conclusions. Specifically, earlier analysis with a smaller data set showed that the most parsimonious model was only the assembler used, regardless of the version or command line arguments. This highlights how this analysis is data-dependent on the source genomes and assemblers, and greater numbers of benchmark genomes, or including additional models terms would likely lead to smaller confidence intervals in the estimated coefficients.</p>
 </div>
 <div id="acknowledgements" class="section level2 unnumbered">
    <h2>Acknowledgements</h2>
    <p>The work was conducted at the U.S. Department of Energy Joint Genome Institute, a DOE Office of Science User Facility, and is supported under Contract No. DE-AC02-05CH11231. Multiple instances of advice and suggestions provided on Cross Validated to make the model fitting part of this analysis possible.</p>
 </div>
 <div id="data-and-model-fitting-notes" class="section level2 unnumbered">
    <h2>Data and Model Fitting Notes</h2>
    <p>Each model was fit with the natural log of the reference genome length as an constant term offset as shown in <a href="#eq:model-fit">Equation 1</a>. This accounts for the different sizes in genomes, where in the context of a Poisson-like model the size of the genome corresponds to the exposure rate for a response effect. For example, when comparing contiguity the response was the NA50 score, and the exposure rate was the size of the genome. Maximum NA50 scores are proportional to the size of the genome examined, and an offset term removes this effect rescaling it to be in the range 0-1.</p>
    <p>Each model was regressed through the origin because all explanatory variables are categorical. If an intercept term were included, this would fit as a constant term when all variables are removed. For example this would estimate what the NA50 would be for no genome and no genome assembler. Therefore by removing the intercept from a model estimated using only categorical variables, the estimated coefficient will be the mean of the response for each term. No interaction terms between assembler and genome were considered when fitting each model. Adding interaction terms would likely produce a better model fit, however the aim of the analysis was to determine the average assembler efficacy without adding individual genome-specific effects for each assembler. Future analysis including model terms for genome-entropy such as percent GC or genome repeat content and compare with the models examined here to see if there would be an improvement in model fit and explanatory power.</p>
    <p>A consideration when estimating confidence intervals was whether the model residuals were over- or under-dispersed, or whether the model fitted values trend with residual size (heteroscedasticity). This was accounted for by fitting a negative binomial model when the data was only over-dispersed, or a double Poisson model when the data was both under- and over-dispersed, <span class="citation">[<a href="#ref-Stasinopoulos2007">30</a>]</span>, <span class="citation">[<a href="#ref-shoukri1982">31</a>]</span>. A negative binomial fit a parameter to allow for over-dispersion, a double Poisson model allowed for fitting both under- and over-dispersion. This was in contrast to Poisson regression which assumes the variance is equal to the mean. Both the double Poisson and negative binomial models use a log-link function for the <span class="math inline">\(\beta\)</span> and <span class="math inline">\(\sigma\)</span> variables, assuming a log-normal distribution of the response variable. The estimated model coefficients were converted back to the original scale by taking the exponent in <a href="#fig:plot-assembler-parameters">Figure 2</a> and <a href="#fig:plot-feature-coef">Figure 4</a>.</p>
    <p>The negative binomial model was favoured over the double Poisson, where possible, because the negative binomial was faster to fit, and with fewer parameters was more parsimonious. These models were fit using the <code>gamlss</code> function from the package of the same name <span class="citation">[<a href="#ref-Stasinopoulos2007">30</a>]</span>. Each model was run for 75 convergence cycles or until the model converged at a tolerance of 0.001 or less. The model fitting was run in parallel using 36 cores on an Amazon c4.8xlarge instance to allow the model fitting to finish in reasonable time.</p>
    <p><a href="#fig:plot-na50-model-fit">Figure 5</a>, <a href="#fig:plot-misassembly-model-fit">Figure 6</a>, <a href="#fig:plot-incorrect-bases-model-fit">Figure 7</a>, and <a href="#fig:plot-feature-model-fit">Figure 8</a> are diagnostics plots for each of the final models from which the assembler coefficients were drawn from. These diagnostic plots were used to ensure that the model residuals were approximately normally distributed, there was no trend in residuals, and that there were no large assembler or genome specific effects in the model residuals. <a href="#tab:na50-model-summary">Table 1</a>, <a href="#tab:table-misassembly-models">Table 3</a>, <a href="#tab:table-incorrect-models">Table 4</a>, and <a href="#tab:table-feature-models">Table 5</a> contrast the top five linear models for each of the assembly metrics considered. <a href="#tab:model-table">Table 6</a> shows all the different linear model parameterisations considered in this analysis.</p>
    <p><a href="#tab:table-images">Table 8</a> lists all the different genome assembler biobox Docker images used in this analysis. <a href="#tab:table-organisms">Table 9</a> lists all the genomes used to benchmark the assemblers. <a href="#tab:table-missing-data">Table 7</a> lists all the instances when a benchmarked image was not able to produce quantifiable output as a result of the benchmarking.</p>

  <%= partial(:figure, :locals => {
    anchor: "fig:plot-na50-model-fit",
    url: amzn('aggregated-assembly-metrics/05-model-fit-check.png'),
    caption_name: "Figure 5: Model checking plots for NA50 fitted model.",
    caption_desc: "These are in clockwise order from upper left: comparison of model residual quantiles with theoretical quantiles, comparison of model residuals with fitted values, comparison of each assembler image model residuals, and comparison of each genome model residuals."}) %>

    <figure>
    <table>
       <thead>
          <tr class="header">
             <th align="left">Fixed Term</th>
             <th align="left">Random Term</th>
             <th align="left">Variance Model</th>
             <th align="right">dBIC</th>
             <th align="right">R.D.F.</th>
             <th align="right">Dev.</th>
             <th align="left">Conv.</th>
          </tr>
       </thead>
       <tbody>
          <tr class="odd">
             <td align="left">Assembler</td>
             <td align="left">Genome</td>
             <td align="left">Assembler + Genome</td>
             <td align="right">0.00</td>
             <td align="right">3697.049</td>
             <td align="right">6294.6</td>
             <td align="left">F</td>
          </tr>
          <tr class="even">
             <td align="left">Assembler Version</td>
             <td align="left">Genome</td>
             <td align="left">Assembler Version + Genome</td>
             <td align="right">60.15</td>
             <td align="right">3677.045</td>
             <td align="right">6190.1</td>
             <td align="left">F</td>
          </tr>
          <tr class="odd">
             <td align="left">Assembler</td>
             <td align="left">Genome</td>
             <td align="left">Genome</td>
             <td align="right">104.18</td>
             <td align="right">3710.087</td>
             <td align="right">6506.1</td>
             <td align="left">F</td>
          </tr>
          <tr class="even">
             <td align="left">Assembler Version</td>
             <td align="left">Genome</td>
             <td align="left">Genome</td>
             <td align="right">111.63</td>
             <td align="right">3700.091</td>
             <td align="right">6431.2</td>
             <td align="left">F</td>
          </tr>
          <tr class="odd">
             <td align="left">Assembler Args</td>
             <td align="left">Genome</td>
             <td align="left">Genome</td>
             <td align="right">153.57</td>
             <td align="right">3675.072</td>
             <td align="right">6267.2</td>
             <td align="left">F</td>
          </tr>
          <tr class="even">
             <td align="left">Assembler</td>
             <td align="left">Genome</td>
             <td align="left">Assembler</td>
             <td align="right">1103.61</td>
             <td align="right">3712.106</td>
             <td align="right">7522.1</td>
             <td align="left">F</td>
          </tr>
       </tbody>
    </table>
    <%= partial(:figure_caption, :locals => {
      caption_name: "Table 3: Summary of first six most parsimonious models with number of misassemblies as the response variable.",
      caption_desc: "The dBIC shows the difference in Bayesian information criterion between the best model and all other models. ‘R.D.F.’ is the residual degrees of freedom in the model. ‘Dev.’ is the residual deviance in the model. ‘Conv.’ states whether the model converged or not (T/F)." }) %>
    </figure>

  <%= partial(:figure, :locals => {
    anchor: "fig:plot-misassembly-model-fit",
    url: amzn('aggregated-assembly-metrics/06-model-fit-check.png'),
    caption_name: "Figure 6: Model checking plots for misassemblies fitted model.",
    caption_desc: "These are in clockwise order from upper left: comparison of model residual quantiles with theoretical quantiles, comparison of model residuals with fitted values, comparison of each assembler image model residuals, and comparison of each genome model residuals."}) %>

    <figure id="tab:table-incorrect-models">
    <table>
       <thead>
          <tr class="header">
             <th align="left">Fixed Term</th>
             <th align="left">Random Term</th>
             <th align="left">Variance Model</th>
             <th align="right">dBIC</th>
             <th align="right">R.D.F.</th>
             <th align="right">Dev.</th>
             <th align="left">Conv.</th>
          </tr>
       </thead>
       <tbody>
          <tr class="odd">
             <td align="left">Assembler Version</td>
             <td align="left">Genome</td>
             <td align="left">Assembler Version + Genome</td>
             <td align="right">0.00</td>
             <td align="right">3677.119</td>
             <td align="right">8404.4</td>
             <td align="left">F</td>
          </tr>
          <tr class="even">
             <td align="left">Assembler</td>
             <td align="left">Genome</td>
             <td align="left">Assembler + Genome</td>
             <td align="right">60.35</td>
             <td align="right">3697.110</td>
             <td align="right">8629.3</td>
             <td align="left">F</td>
          </tr>
          <tr class="odd">
             <td align="left">Assembler Version</td>
             <td align="left">Genome</td>
             <td align="left">Assembler Version</td>
             <td align="right">370.94</td>
             <td align="right">3692.037</td>
             <td align="right">8898.1</td>
             <td align="left">F</td>
          </tr>
          <tr class="even">
             <td align="left">Assembler</td>
             <td align="left">Genome</td>
             <td align="left">Assembler</td>
             <td align="right">396.52</td>
             <td align="right">3712.045</td>
             <td align="right">9088.4</td>
             <td align="left">F</td>
          </tr>
          <tr class="odd">
             <td align="left">Assembler Version</td>
             <td align="left">Input FASTA</td>
             <td align="left">Assembler Version</td>
             <td align="right">841.36</td>
             <td align="right">3629.771</td>
             <td align="right">8856.0</td>
             <td align="left">F</td>
          </tr>
          <tr class="even">
             <td align="left">Assembler</td>
             <td align="left">Input FASTA</td>
             <td align="left">Assembler</td>
             <td align="right">873.33</td>
             <td align="right">3649.775</td>
             <td align="right">9052.6</td>
             <td align="left">F</td>
          </tr>
       </tbody>
    </table>
    <%= partial(:figure_caption, :locals => {
      caption_name: "Table 4: Summary of first six most parsimonious models with number of incorrect bases as the response variable.",
      caption_desc: "The dBIC shows the difference in Bayesian information criterion between the best model and all other models. ‘R.D.F.’ is the residual degrees of freedom in the model. ‘Dev.’ is the residual deviance in the model. ‘Conv.’ states whether the model converged or not (T/F)." }) %>
    </figure>

  <%= partial(:figure, :locals => {
    anchor: "fig:plot-incorrect-bases-model-fit",
    url: amzn('aggregated-assembly-metrics/07-model-fit-check.png'),
    caption_name: "Figure 7: Model checking plots for incorrect bases model.",
    caption_desc: "These are in clockwise order from upper left: comparison of model residual quantiles with theoretical quantiles, comparison of model residuals with fitted values, comparison of each assembler image model residuals, and comparison of each genome model residuals."}) %>

    <figure id="tab:table-feature-models">
    <table>
       <thead>
          <tr class="header">
             <th align="left">Fixed Term</th>
             <th align="left">Random Term</th>
             <th align="left">Variance Model</th>
             <th align="right">dBIC</th>
             <th align="right">R.D.F.</th>
             <th align="right">Dev.</th>
             <th align="left">Conv.</th>
          </tr>
       </thead>
       <tbody>
          <tr class="odd">
             <td align="left">Assembler Args</td>
             <td align="left">Genome</td>
             <td align="left">Assembler Args + Genome</td>
             <td align="right">0.00</td>
             <td align="right">3627.002</td>
             <td align="right">37732.5</td>
             <td align="left">T</td>
          </tr>
          <tr class="even">
             <td align="left">Assembler Args</td>
             <td align="left">Input FASTA</td>
             <td align="left">Assembler Args + Input FASTA</td>
             <td align="right">1045.27</td>
             <td align="right">3499.044</td>
             <td align="right">37724.5</td>
             <td align="left">F</td>
          </tr>
          <tr class="odd">
             <td align="left">Assembler Version</td>
             <td align="left">Genome</td>
             <td align="left">Assembler Version + Genome</td>
             <td align="right">1461.26</td>
             <td align="right">3677.009</td>
             <td align="right">39605.3</td>
             <td align="left">T</td>
          </tr>
          <tr class="even">
             <td align="left">Assembler</td>
             <td align="left">Genome</td>
             <td align="left">Assembler + Genome</td>
             <td align="right">2282.73</td>
             <td align="right">3697.007</td>
             <td align="right">40591.4</td>
             <td align="left">T</td>
          </tr>
          <tr class="odd">
             <td align="left">Assembler Version</td>
             <td align="left">Input FASTA</td>
             <td align="left">Assembler Version + Input FASTA</td>
             <td align="right">2421.13</td>
             <td align="right">3549.216</td>
             <td align="right">39513.3</td>
             <td align="left">T</td>
          </tr>
          <tr class="even">
             <td align="left">Assembler</td>
             <td align="left">Input FASTA</td>
             <td align="left">Assembler + Input FASTA</td>
             <td align="right">3336.75</td>
             <td align="right">3569.135</td>
             <td align="right">40592.9</td>
             <td align="left">F</td>
          </tr>
       </tbody>
    </table>
    <%= partial(:figure_caption, :locals => {
      caption_name: "Table 5: Summary of first six most parsimonious models with L1 norm feature distance between reference and assembly as the response variable.",
      caption_desc: "The dBIC shows the difference in Bayesian information criterion between the best model and all other models. ‘R.D.F.’ is the residual degrees of freedom in the model. ‘Dev.’ is the residual deviance in the model. ‘Conv.’ states whether the model converged or not (T/F)." }) %>
    </figure>

  <%= partial(:figure, :locals => {
    anchor: "fig:plot-feature-model-fit",
    url: amzn('aggregated-assembly-metrics/08-model-fit-check.png'),
    caption_name: "Figure 8: Model checking plots for feature L1 norm fitted model.",
    caption_desc: "These are in clockwise order from upper left: comparison of model residual quantiles with theoretical quantiles, comparison of model residuals with fitted values, comparison of each assembler image model residuals, and comparison of each genome model residuals."}) %>

    <figure id="tab:model-table">
    <table>
       <thead>
          <tr class="header">
             <th align="left">Fixed Term</th>
             <th align="left">Random Term</th>
             <th align="left">Variance Model</th>
          </tr>
       </thead>
       <tbody>
          <tr class="odd">
             <td align="left">Null</td>
             <td align="left">Null</td>
             <td align="left">Null</td>
          </tr>
          <tr class="even">
             <td align="left">Null</td>
             <td align="left">Genome</td>
             <td align="left">Null</td>
          </tr>
          <tr class="odd">
             <td align="left">Null</td>
             <td align="left">Genome</td>
             <td align="left">Genome</td>
          </tr>
          <tr class="even">
             <td align="left">Null</td>
             <td align="left">Input FASTA</td>
             <td align="left">Null</td>
          </tr>
          <tr class="odd">
             <td align="left">Null</td>
             <td align="left">Input FASTA</td>
             <td align="left">Input FASTA</td>
          </tr>
          <tr class="even">
             <td align="left">Assembler</td>
             <td align="left">Null</td>
             <td align="left">Null</td>
          </tr>
          <tr class="odd">
             <td align="left">Assembler</td>
             <td align="left">Null</td>
             <td align="left">Assembler</td>
          </tr>
          <tr class="even">
             <td align="left">Assembler</td>
             <td align="left">Genome</td>
             <td align="left">Null</td>
          </tr>
          <tr class="odd">
             <td align="left">Assembler</td>
             <td align="left">Genome</td>
             <td align="left">Genome</td>
          </tr>
          <tr class="even">
             <td align="left">Assembler</td>
             <td align="left">Genome</td>
             <td align="left">Assembler</td>
          </tr>
          <tr class="odd">
             <td align="left">Assembler</td>
             <td align="left">Genome</td>
             <td align="left">Assembler + Genome</td>
          </tr>
          <tr class="even">
             <td align="left">Assembler</td>
             <td align="left">Input FASTA</td>
             <td align="left">Null</td>
          </tr>
          <tr class="odd">
             <td align="left">Assembler</td>
             <td align="left">Input FASTA</td>
             <td align="left">Input FASTA</td>
          </tr>
          <tr class="even">
             <td align="left">Assembler</td>
             <td align="left">Input FASTA</td>
             <td align="left">Assembler</td>
          </tr>
          <tr class="odd">
             <td align="left">Assembler</td>
             <td align="left">Input FASTA</td>
             <td align="left">Assembler + Input FASTA</td>
          </tr>
          <tr class="even">
             <td align="left">Assembler Version</td>
             <td align="left">Null</td>
             <td align="left">Null</td>
          </tr>
          <tr class="odd">
             <td align="left">Assembler Version</td>
             <td align="left">Null</td>
             <td align="left">Assembler Version</td>
          </tr>
          <tr class="even">
             <td align="left">Assembler Version</td>
             <td align="left">Genome</td>
             <td align="left">Null</td>
          </tr>
          <tr class="odd">
             <td align="left">Assembler Version</td>
             <td align="left">Genome</td>
             <td align="left">Genome</td>
          </tr>
          <tr class="even">
             <td align="left">Assembler Version</td>
             <td align="left">Genome</td>
             <td align="left">Assembler Version</td>
          </tr>
          <tr class="odd">
             <td align="left">Assembler Version</td>
             <td align="left">Genome</td>
             <td align="left">Assembler Version + Genome</td>
          </tr>
          <tr class="even">
             <td align="left">Assembler Version</td>
             <td align="left">Input FASTA</td>
             <td align="left">Null</td>
          </tr>
          <tr class="odd">
             <td align="left">Assembler Version</td>
             <td align="left">Input FASTA</td>
             <td align="left">Input FASTA</td>
          </tr>
          <tr class="even">
             <td align="left">Assembler Version</td>
             <td align="left">Input FASTA</td>
             <td align="left">Assembler Version</td>
          </tr>
          <tr class="odd">
             <td align="left">Assembler Version</td>
             <td align="left">Input FASTA</td>
             <td align="left">Assembler Version + Input FASTA</td>
          </tr>
          <tr class="even">
             <td align="left">Assembler Args</td>
             <td align="left">Null</td>
             <td align="left">Null</td>
          </tr>
          <tr class="odd">
             <td align="left">Assembler Args</td>
             <td align="left">Null</td>
             <td align="left">Assembler Args</td>
          </tr>
          <tr class="even">
             <td align="left">Assembler Args</td>
             <td align="left">Genome</td>
             <td align="left">Null</td>
          </tr>
          <tr class="odd">
             <td align="left">Assembler Args</td>
             <td align="left">Genome</td>
             <td align="left">Genome</td>
          </tr>
          <tr class="even">
             <td align="left">Assembler Args</td>
             <td align="left">Genome</td>
             <td align="left">Assembler Args</td>
          </tr>
          <tr class="odd">
             <td align="left">Assembler Args</td>
             <td align="left">Genome</td>
             <td align="left">Assembler Args + Genome</td>
          </tr>
          <tr class="even">
             <td align="left">Assembler Args</td>
             <td align="left">Input FASTA</td>
             <td align="left">Null</td>
          </tr>
          <tr class="odd">
             <td align="left">Assembler Args</td>
             <td align="left">Input FASTA</td>
             <td align="left">Input FASTA</td>
          </tr>
          <tr class="even">
             <td align="left">Assembler Args</td>
             <td align="left">Input FASTA</td>
             <td align="left">Assembler Args</td>
          </tr>
          <tr class="odd">
             <td align="left">Assembler Args</td>
             <td align="left">Input FASTA</td>
             <td align="left">Assembler Args + Input FASTA</td>
          </tr>
       </tbody>
    </table>

    <%= partial(:figure_caption, :locals => {
      caption_name: "Table 6: Comparison of the mixed effect models considered in this analysis, where each row defines the terms used in the model. ",
      caption_desc: "The ‘Fixed’ and ‘Random’ terms are those fitted as explanatory variables, along with the natural log of the genome length. The ‘Variance Model’ column lists where the variance was also modelled as a component, i.e. whether different terms had different variances. Null terms indicate that this was simply modelled as the mean of the data with a model estimated constant coefficient." }) %>
    </figure>

    <figure>
    <table>
       <thead>
          <tr class="header">
             <th align="left">Assembler</th>
             <th align="left">Version</th>
             <th align="left">Task</th>
             <th align="right">#Incomplete</th>
          </tr>
       </thead>
       <tbody>
          <tr class="odd">
             <td align="left">stride</td>
             <td align="left">0.0.1-preprocessing</td>
             <td align="left">isolate</td>
             <td align="right">74</td>
          </tr>
          <tr class="even">
             <td align="left">stride</td>
             <td align="left">0.0.1-preprocessing</td>
             <td align="left">single-cell</td>
             <td align="right">64</td>
          </tr>
          <tr class="odd">
             <td align="left">velvet</td>
             <td align="left">1.2.0</td>
             <td align="left">default</td>
             <td align="right">11</td>
          </tr>
          <tr class="even">
             <td align="left">tadpole</td>
             <td align="left">36.38</td>
             <td align="left">careful</td>
             <td align="right">5</td>
          </tr>
          <tr class="odd">
             <td align="left">tadpole</td>
             <td align="left">36.38</td>
             <td align="left">default</td>
             <td align="right">5</td>
          </tr>
          <tr class="even">
             <td align="left">stride</td>
             <td align="left">0.0.1-preprocessing</td>
             <td align="left">default</td>
             <td align="right">2</td>
          </tr>
          <tr class="odd">
             <td align="left">shovill</td>
             <td align="left">0.2</td>
             <td align="left">default</td>
             <td align="right">1</td>
          </tr>
          <tr class="even">
             <td align="left">shovill</td>
             <td align="left">0.7.1</td>
             <td align="left">default</td>
             <td align="right">1</td>
          </tr>
          <tr class="odd">
             <td align="left">stride</td>
             <td align="left">0.0.1</td>
             <td align="left">default</td>
             <td align="right">1</td>
          </tr>
       </tbody>
    </table>
    <%= partial(:figure_caption, :locals => {
      caption_name: "Table 7: List of biobox images failing to produce an assembly when run on benchmarking data.",
      caption_desc: "" }) %>
    </figure>

    <figure id="tab:table-images">
    <table>
       <thead>
          <tr class="header">
             <th align="left">Assembler</th>
             <th align="left">Version</th>
          </tr>
       </thead>
       <tbody>
          <tr class="odd">
             <td align="left">abyss</td>
             <td align="left">2.0.1</td>
          </tr>
          <tr class="even">
             <td align="left">docker-a5-miseq</td>
             <td align="left">20160825</td>
          </tr>
          <tr class="odd">
             <td align="left">gatb-minia</td>
             <td align="left">20161208-a4c6e8c</td>
          </tr>
          <tr class="even">
             <td align="left">jgi-isolate-pipeline</td>
             <td align="left">v0.10.0</td>
          </tr>
          <tr class="odd">
             <td align="left">jgi-isolate-pipeline</td>
             <td align="left">v0.11.0</td>
          </tr>
          <tr class="even">
             <td align="left">jgi-isolate-pipeline</td>
             <td align="left">v0.12.0</td>
          </tr>
          <tr class="odd">
             <td align="left">light-assembler</td>
             <td align="left">20161003-ed93715</td>
          </tr>
          <tr class="even">
             <td align="left">megahit</td>
             <td align="left">1.0.6</td>
          </tr>
          <tr class="odd">
             <td align="left">megahit</td>
             <td align="left">1.1.1</td>
          </tr>
          <tr class="even">
             <td align="left">ray</td>
             <td align="left">2.3.0</td>
          </tr>
          <tr class="odd">
             <td align="left">sga</td>
             <td align="left">v0.10.13</td>
          </tr>
          <tr class="even">
             <td align="left">shovill</td>
             <td align="left">0.2</td>
          </tr>
          <tr class="odd">
             <td align="left">shovill</td>
             <td align="left">0.4</td>
          </tr>
          <tr class="even">
             <td align="left">shovill</td>
             <td align="left">0.7.1</td>
          </tr>
          <tr class="odd">
             <td align="left">spades</td>
             <td align="left">3.10.0</td>
          </tr>
          <tr class="even">
             <td align="left">spades</td>
             <td align="left">3.10.1</td>
          </tr>
          <tr class="odd">
             <td align="left">spades</td>
             <td align="left">3.11.0</td>
          </tr>
          <tr class="even">
             <td align="left">spades</td>
             <td align="left">3.11.0-fix-merge-task</td>
          </tr>
          <tr class="odd">
             <td align="left">spades</td>
             <td align="left">3.9.0</td>
          </tr>
          <tr class="even">
             <td align="left">stride</td>
             <td align="left">0.0.1</td>
          </tr>
          <tr class="odd">
             <td align="left">stride</td>
             <td align="left">0.0.1-preprocessing</td>
          </tr>
          <tr class="even">
             <td align="left">tadpole</td>
             <td align="left">36.38</td>
          </tr>
          <tr class="odd">
             <td align="left">unicycler</td>
             <td align="left">v0.4.1</td>
          </tr>
          <tr class="even">
             <td align="left">velvet</td>
             <td align="left">1.2.0</td>
          </tr>
       </tbody>
    </table>
    <%= partial(:figure_caption, :locals => {
      caption_name: "Table 8: List of biobox short read assembler Docker images used in the benchmarks.",
      caption_desc: "" }) %>
    </figure>


    <figure>
    <table>
       <thead>
          <tr class="header">
             <th align="left">Biological Source</th>
             <th align="right">Length (MBp)</th>
             <th align="right">%GC</th>
          </tr>
       </thead>
       <tbody>
          <tr class="odd">
             <td align="left">Algiphilus aromaticivorans</td>
             <td align="right">3.81</td>
             <td align="right">66.38</td>
          </tr>
          <tr class="even">
             <td align="left">Amycolatopsis sulphurea</td>
             <td align="right">6.86</td>
             <td align="right">69.41</td>
          </tr>
          <tr class="odd">
             <td align="left">Arenibacter algicola</td>
             <td align="right">5.55</td>
             <td align="right">39.74</td>
          </tr>
          <tr class="even">
             <td align="left">Desulfosporosinus acidophilus</td>
             <td align="right">4.99</td>
             <td align="right">42.11</td>
          </tr>
          <tr class="odd">
             <td align="left">Desulfosporosinus meridiei</td>
             <td align="right">4.87</td>
             <td align="right">41.78</td>
          </tr>
          <tr class="even">
             <td align="left">Escherichia coli</td>
             <td align="right">4.64</td>
             <td align="right">50.79</td>
          </tr>
          <tr class="odd">
             <td align="left">Fervidobacterium pennivorans</td>
             <td align="right">2.17</td>
             <td align="right">38.88</td>
          </tr>
          <tr class="even">
             <td align="left">Hirschia baltica</td>
             <td align="right">3.54</td>
             <td align="right">45.19</td>
          </tr>
          <tr class="odd">
             <td align="left">Meiothermus ruber</td>
             <td align="right">3.10</td>
             <td align="right">63.38</td>
          </tr>
          <tr class="even">
             <td align="left">Meiothermus silvanus</td>
             <td align="right">3.72</td>
             <td align="right">62.72</td>
          </tr>
          <tr class="odd">
             <td align="left">Pedobacter heparinus</td>
             <td align="right">5.17</td>
             <td align="right">42.05</td>
          </tr>
          <tr class="even">
             <td align="left">Polycyclovorans algicola</td>
             <td align="right">3.65</td>
             <td align="right">63.78</td>
          </tr>
          <tr class="odd">
             <td align="left">Porticoccus hydrocarbonoclasticus</td>
             <td align="right">2.47</td>
             <td align="right">53.07</td>
          </tr>
          <tr class="even">
             <td align="left">Saccharopolyspora spinosa</td>
             <td align="right">9.02</td>
             <td align="right">67.95</td>
          </tr>
          <tr class="odd">
             <td align="left">Spirochaeta smaragdinae</td>
             <td align="right">4.65</td>
             <td align="right">48.97</td>
          </tr>
          <tr class="even">
             <td align="left">Thermobacillus composti</td>
             <td align="right">4.36</td>
             <td align="right">60.12</td>
          </tr>
       </tbody>
    </table>
    <%= partial(:figure_caption, :locals => {
      caption_name: "Table 9: List of source microbial genomes used in the benchmarks.",
      caption_desc: "" }) %>

 </div>
 <div id="references" class="section level2 unnumbered">
    <h2>References</h2>
    <!--chapter:end:notebook.Rmd-->
    <div id="refs" class="references">
       <div id="ref-earl2011">
          <p>1. Earl DA, Bradnam K, St. John J, Darling A, Lin D, Faas J, et al. Assemblathon 1: A competitive assessment of <em>de novo</em> short read assembly methods. Genome Research. Cold Spring Harbor Laboratory Press; 2011;21: 2224–2241. doi:<a href="https://doi.org/10.1101/gr.126599.111">10.1101/gr.126599.111</a></p>
       </div>
       <div id="ref-bradnam2013">
          <p>2. Bradnam KR, Fass JN, Alexandrov A, Baranay P, Bechner M, Birol I, et al. Assemblathon 2: Evaluating <em>de novo</em> methods of genome assembly in three vertebrate species. GigaScience. 2013;2: 10+. doi:<a href="https://doi.org/10.1186/2047-217x-2-10">10.1186/2047-217x-2-10</a></p>
       </div>
       <div id="ref-salzberg2012">
          <p>3. Salzberg SL, Phillippy AM, Zimin A, Puiu D, Magoc T, Koren S, et al. GAGE: A critical evaluation of genome assemblies and assembly algorithms. Genome research. Cold Spring Harbor Laboratory Press; 2012;22: 557–567. doi:<a href="https://doi.org/10.1101/gr.131383.111">10.1101/gr.131383.111</a></p>
       </div>
       <div id="ref-sczyrba2017">
          <p>4. Sczyrba A, Hofmann P, Belmann P, Koslicki D, Janssen S, Dröge J, et al. Critical assessment of metagenome interpretation-a benchmark of metagenomics software. Nature methods. 2017;14: 1063–1071. doi:<a href="https://doi.org/doi:10.1038/nmeth.4458">doi:10.1038/nmeth.4458</a></p>
       </div>
       <div id="ref-belmann2015">
          <p>5. Belmann P, Dröge J, Bremges A, McHardy AC, Sczyrba A, Barton MD. Bioboxes: Standardised containers for interchangeable bioinformatics software. GigaScience. 2015;4. doi:<a href="https://doi.org/10.1186/s13742-015-0087-0">10.1186/s13742-015-0087-0</a></p>
       </div>
       <div id="ref-gurevich2013">
          <p>6. Gurevich A, Saveliev V, Vyahhi N, Tesler G. QUAST: Quality assessment tool for genome assemblies. Bioinformatics (Oxford, England). Oxford University Press; 2013;29: 1072–1075. doi:<a href="https://doi.org/10.1093/bioinformatics/btt086">10.1093/bioinformatics/btt086</a></p>
       </div>
       <div id="ref-simpson2009">
          <p>7. Simpson JT, Wong K, Jackman SD, Schein JE, Jones SJ, Birol I. ABySS: A parallel assembler for short read sequence data. Genome research. Cold Spring Harbor Laboratory Press; 2009;19: 1117–1123. doi:<a href="https://doi.org/10.1101/gr.089532.108">10.1101/gr.089532.108</a></p>
       </div>
       <div id="ref-coil2015">
          <p>8. Coil D, Jospin G, Darling AE. A5-miseq: An updated pipeline to assemble microbial genomes from Illumina MiSeq data. Bioinformatics (Oxford, England). Oxford University Press; 2015;31: 587–589. doi:<a href="https://doi.org/10.1093/bioinformatics/btu661">10.1093/bioinformatics/btu661</a></p>
       </div>
       <div id="ref-chiki2013">
          <p>9. Chikhi R, Rizk G. Space-efficient and exact de Bruijn graph representation based on a Bloom filter. Algorithms for molecular biology : AMB. 2013;8: 22+. doi:<a href="https://doi.org/10.1186/1748-7188-8-22">10.1186/1748-7188-8-22</a></p>
       </div>
       <div id="ref-metwally2016">
          <p>10. El-Metwally S, Zakaria M, Hamza T. LightAssembler: Fast and memory-efficient assembly algorithm for high-throughput sequencing reads. Bioinformatics (Oxford, England). Oxford University Press; 2016;32: 3215–3223. doi:<a href="https://doi.org/10.1093/bioinformatics/btw470">10.1093/bioinformatics/btw470</a></p>
       </div>
       <div id="ref-li2015">
          <p>11. Li D, Liu C-MM, Luo R, Sadakane K, Lam T-WW. MEGAHIT: An ultra-fast single-node solution for large and complex metagenomics assembly via succinct de Bruijn graph. Bioinformatics (Oxford, England). Oxford University Press; 2015;31: 1674–1676. doi:<a href="https://doi.org/10.1093/bioinformatics/btv033">10.1093/bioinformatics/btv033</a></p>
       </div>
       <div id="ref-li2016">
          <p>12. Li D, Luo R, Liu C-MM, Leung C-MM, Ting H-FF, Sadakane K, et al. MEGAHIT v1.0: A fast and scalable metagenome assembler driven by advanced methodologies and community practices. Methods (San Diego, Calif). 2016;102: 3–11. doi:<a href="https://doi.org/doi.org/10.1016/j.ymeth.2016.02.020">doi.org/10.1016/j.ymeth.2016.02.020</a></p>
       </div>
       <div id="ref-boisvert2010">
          <p>13. Boisvert S, Laviolette F, Corbeil J. Ray: Simultaneous assembly of reads from a mix of high-throughput sequencing technologies. Journal of computational biology : a journal of computational molecular cell biology. 2010;17: 1519–1533. doi:<a href="https://doi.org/10.1089/cmb.2009.0238">10.1089/cmb.2009.0238</a></p>
       </div>
       <div id="ref-bankevich2012">
          <p>14. Bankevich A, Nurk S, Antipov D, Gurevich AA, Dvorkin M, Kulikov AS, et al. SPAdes: A new genome assembly algorithm and its applications to single-cell sequencing. Journal of computational biology : a journal of computational molecular cell biology. Mary Ann Liebert, Inc., publishers; 2012;19: 455–477. doi:<a href="https://doi.org/10.1089/cmb.2012.0021">10.1089/cmb.2012.0021</a></p>
       </div>
       <div id="ref-huang2016">
          <p>15. Huang Y-TT, Liao C-FF. Integration of string and de Bruijn graphs for genome assembly. Bioinformatics (Oxford, England). 2016;32: 1301–1307. doi:<a href="https://doi.org/10.1093/bioinformatics/btw011">10.1093/bioinformatics/btw011</a></p>
       </div>
       <div id="ref-wick2017">
          <p>16. Wick RR, Judd LM, Gorrie CL, Holt KE. Unicycler: Resolving bacterial genome assemblies from short and long sequencing reads. PLoS computational biology. 2017;13. doi:<a href="https://doi.org/10.1371/journal.pcbi.1005595">10.1371/journal.pcbi.1005595</a></p>
       </div>
       <div id="ref-zerbino2008">
          <p>17. Zerbino DR, Birney E. Velvet: Algorithms for <em>de novo</em> short read assembly using de Bruijn graphs. Genome research. Cold Spring Harbor Laboratory Press; 2008;18: 821–829. doi:<a href="https://doi.org/10.1101/gr.074492.107">10.1101/gr.074492.107</a></p>
       </div>
       <div id="ref-ghodsi2013">
          <p>18. Ghodsi M, Hill CM, Astrovskaya I, Lin H, Sommer DD, Koren S, et al. <em>De novo</em> likelihood-based measures for comparing genome assemblies. BMC research notes. 2013;6: 334+. doi:<a href="https://doi.org/10.1186/1756-0500-6-334">10.1186/1756-0500-6-334</a></p>
       </div>
       <div id="ref-simao2015">
          <p>19. Simão FA, Waterhouse RM, Ioannidis P, Kriventseva EV, Zdobnov EM. BUSCO: Assessing genome assembly and annotation completeness with single-copy orthologs. Bioinformatics (Oxford, England). Oxford University Press; 2015;31: 3210–3212. doi:<a href="https://doi.org/10.1093/bioinformatics/btv351">10.1093/bioinformatics/btv351</a></p>
       </div>
       <div id="ref-meader2010">
          <p>20. Meader S, Hillier LW, Locke D, Ponting CP, Lunter G. Genome assembly quality: Assessment and improvement using the neutral indel model. Genome research. 2010;20: 675–684. doi:<a href="https://doi.org/10.1101/gr.096966.109">10.1101/gr.096966.109</a></p>
       </div>
       <div id="ref-parks2015">
          <p>21. Parks DH, Imelfort M, Skennerton CT, Hugenholtz P, Tyson GW. CheckM: Assessing the quality of microbial genomes recovered from isolates, single cells, and metagenomes. Genome research. Cold Spring Harbor Laboratory Press; 2015;25: 1043–1055. doi:<a href="https://doi.org/10.1101/gr.186072.114">10.1101/gr.186072.114</a></p>
       </div>
       <div id="ref-phillippy2008">
          <p>22. Phillippy AM, Schatz MC, Pop M. Genome assembly forensics: Finding the elusive mis-assembly. Genome biology. 2008;9: R55+. doi:<a href="https://doi.org/10.1186/gb-2008-9-3-r55">10.1186/gb-2008-9-3-r55</a></p>
       </div>
       <div id="ref-hunt2013">
          <p>23. Hunt M, Kikuchi T, Sanders M, Newbold C, Berriman M, Otto TD. REAPR: A universal tool for genome assembly evaluation. Genome biology. BioMed Central Ltd; 2013;14: R47+. doi:<a href="https://doi.org/10.1186/gb-2013-14-5-r47">10.1186/gb-2013-14-5-r47</a></p>
       </div>
       <div id="ref-florea2011">
          <p>24. Florea L, Souvorov A, Kalbfleisch TS, Salzberg SL. Genome assembly has a major impact on gene content: A comparison of annotation in two <em>bos taurus</em> assemblies. PloS one. 2011;6. doi:<a href="https://doi.org/10.1371/journal.pone.0021400">10.1371/journal.pone.0021400</a></p>
       </div>
       <div id="ref-vezzi2012">
          <p>25. Vezzi F, Narzisi G, Mishra B. Reevaluating assembly evaluations with feature response curves: GAGE and assemblathons. PloS one. Public Library of Science; 2012;7: e52210+. doi:<a href="https://doi.org/10.1371/journal.pone.0052210">10.1371/journal.pone.0052210</a></p>
       </div>
       <div id="ref-schwarz1978">
          <p>26. Schwarz G. Estimating the dimension of a model. The Annals of Statistics. 1978;6: 461–464. doi:<a href="https://doi.org/10.1214/aos/1176344136">10.1214/aos/1176344136</a></p>
       </div>
       <div id="ref-burnham2004">
          <p>27. Burnham KP, Anderson DR. Multimodel inference. Sociological Methods &amp; Research. SAGE Publications; 2004;33: 261–304. doi:<a href="https://doi.org/10.1177/0049124104268644">10.1177/0049124104268644</a></p>
       </div>
       <div id="ref-koren2015">
          <p>28. Koren S, Phillippy AM. One chromosome, one contig: Complete microbial genomes from long-read sequencing and assembly. Current Opinion in Microbiology. 2015;23: 110–120. doi:<a href="https://doi.org/10.1016/j.mib.2014.11.014">10.1016/j.mib.2014.11.014</a></p>
       </div>
       <div id="ref-burnham2002">
          <p>29. Burnham KP, Anderson DR. Model selection and multimodel inference: A practical information-theoretic approach. 2nd ed. Springer; 2002. pp. 1–488. </p>
       </div>
       <div id="ref-Stasinopoulos2007">
          <p>30. Stasinopoulos D, Rigby R. Generalized additive models for location scale and shape (gamlss) in R. Journal of Statistical Software, Articles. 2007;23: 1–46. doi:<a href="https://doi.org/10.18637/jss.v023.i07">10.18637/jss.v023.i07</a></p>
       </div>
       <div id="ref-shoukri1982">
          <p>31. Shoukri MM. On the generalization and estimation for the double Poisson distribution. Springer-Verlag; 1982;33: 97–109. doi:<a href="https://doi.org/10.1007/bf02888625">10.1007/bf02888625</a></p>
       </div>
    </div>
 </div>
 <div class="footnotes">
    <hr />
    <ol>
       <li id="fn1">
          <p>The <a href="http://www.bodowinter.com/tutorial/bw_LME_tutorial1.pdf">linear models and linear mixed effects models in R (PDF)</a> tutorial provides an explanation of why mixed effect models are used to model group level variance. In this case the group level variance is the source genome, and each individual observation is the FASTQ file given to the genome assembler.<a href="#fnref1">↩</a></p>
       </li>
       <li id="fn2">
          <p>As the free parameter penalty increases by the log of the number of observations, BIC has been described as a better choice than AIC for larger data sets <span class="citation">[<a href="#ref-schwarz1978">26</a>]</span>, <span class="citation">[<a href="#ref-burnham2004">27</a>]</span><a href="#fnref2">↩</a></p>
       </li>
       <li id="fn3">
          <p>Based on suggested <a href="http://www.ashander.info/posts/2015/10/model-selection-glms-aic-what-to-report/">what to report when comparing models</a>.<a href="#fnref3">↩</a></p>
       </li>
       <li id="fn4">
          <p>A given assembler estimated coefficient would added to a given genome estimated coefficient before being exponentiated to predict what the given metric should be for the genome. This is because the parameters are estimated as a linear model before being generalised with a log-normal link function to a Poisson 0-Inf distribution.<a href="#fnref4">↩</a></p>
       </li>
       <li id="fn5">
          <p>This does not use sequence alignment, but is instead a set operation. Does this exact annotation sequence in the reference also appear in the set of sequences annotated in the assembly? The L1 norm is the sum of these annotation differences between the reference and the assembly.<a href="#fnref5">↩</a></p>
       </li>
    </ol>
 </div>
